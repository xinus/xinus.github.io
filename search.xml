<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[WebRTC学习笔记（1）- Win/Linux/macOS环境编译]]></title>
      <url>%2F2017%2F03%2Fstudy-webrtc-setup%2F</url>
      <content type="text"><![CDATA[准备工作WebRTC属于Chromium项目的子项目，本身可以独立编译，支持的平台包括Windows/Linux/macOS/Android/iOS等。项目本身是C++, 编译脚本也会用到Python。而项目代码托管于Google的服务器上，也就造成国内想要获取源代码，需通过科学上网的方式。所以，一些前置条件必不可少。 环境准备 Win7 64位及以上，笔者用的Win10 64位； macOS； Ubuntu，一定要是Ubuntu，笔者最先用的Mint也被迫换成Ubuntu； 科学上网(VPN等)这是获取代码的关键，整个工程下来，约几个G的容量。 获取depot tools整个工程又细分为多个子工程，不同平台拉取的东西不一样，所以需要官方提供的工具解决依赖问题。原文在这里。 Git 2.2.1+ Win平台使用 Msys (Git for Windows); Mac平台自带； Ubuntu通过apt命令安装； Python 2.7+ Win平台使用 Python 2.7.x, 不要下载3.x版本，不兼容； Mac平台自带； Ubuntu若没自带可通过apt命令安装； depot_tools Mac/Ubuntu通过git获取 1$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 编辑 ~/.bashrc, 添加到环境变量中 1$ export PATH=`pwd`/depot_tools:"$PATH" 注意 pwd 是depot_tools所在目录的路径。 Windows下载depot_tools.zip然后把路径添加到系统的环境变量 PATH : C:\path\to\depot_tools;%PATH% 完成这些步骤后，新开一个命令行窗口，尝试使用 gclient --help，一切顺利则能看到相关提示输出。 获取代码并编译 创建一个目录，并拉取代码: 1234$ mkdir webrtc-checkout$ cd webrtc-checkout$ fetch --nohooks webrtc$ gclient sync 整个过程，根据平台和网络情况的不同，需要数十分钟到几个小时不等。通过fetch --help可以看到更多项目。 然后解决运行脚本，解决一些依赖，为编译做准备： 1$ gclient runhooks 整个过程比上个环境需要的时间更长一些。 Windows平台编译Linux平台编译macOS平台编译常见的问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS下面查看执行文件依赖信息]]></title>
      <url>%2F2017%2F03%2Fotool-intro%2F</url>
      <content type="text"><![CDATA[查看动态链接库信息通过otool查看：12345678$ otool -L CppRestCppRest: /usr/local/opt/cpprestsdk/lib/libcpprest.2.9.dylib (compatibility version 2.9.0, current version 0.0.0) /usr/local/opt/openssl/lib/libssl.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0) /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib (compatibility version 1.0.0, current version 1.0.0) /usr/local/opt/boost/lib/libboost_system.dylib (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0) 查看符号表通过nm查看:123456789101112131415161718192021nm CppRest000000010000a21c s GCC_except_table138000000010000a234 s GCC_except_table148000000010000a254 s GCC_except_table156000000010000a280 s GCC_except_table159000000010000a2bc s GCC_except_table166...0000000100001370 t __ZN5boost4asio5error16get_ssl_categoryEv00000001000012f0 t __ZN5boost4asio5error17get_misc_categoryEv00000001000011f0 t __ZN5boost4asio5error18get_netdb_categoryEv...0000000100009970 t ___cxx_global_var_init0000000100009990 t ___cxx_global_var_init.10000000100009a90 t ___cxx_global_var_init.120000000100009af0 t ___cxx_global_var_init.130000000100009b50 t ___cxx_global_var_init.140000000100009bb0 t ___cxx_global_var_init.150000000100009c10 t ___cxx_global_var_init.1600000001000099b0 t ___cxx_global_var_init.200000001000099d0 t ___cxx_global_var_init.3...]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Electron入坑笔记]]></title>
      <url>%2F2017%2F01%2Felectron-start%2F</url>
      <content type="text"><![CDATA[前置条件1. Node &amp;&amp; NPM前往官方下载, 然后修改为国内的淘宝镜像https://npm.taobao.org/。12$ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install [name] 后面的Shell命令中，用cnpm替代npm 2. Electron通过npm安装。1$ npm install electron -g 在项目中安装。1$ npm install --save-dev electron 3. Electron installer主要用户打包安装包，通过npm安装。1$ npm install electron-packager -g 4. Bower &amp;&amp; Bootstrap安装Bower包管理工具，用来管理前端的js、CSS。通过 Bower 可以安装并管理 Bootstrap 的Less、CSS、JavaScript和字体文件。1$ npm install -g bower 安装Bootstrap。1$ bower install bootstrap Demo &amp;&amp; Exampleselectron-quick-start1234$ git clone https://github.com/electron/electron-quick-start$ cd electron-quick-start$ npm install$ npm start electron-api-demos1234$ git clone https://github.com/electron/electron-api-demos$ cd electron-api-demos$ npm install$ npm start]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[糟糕的 [@[] mutableCopy] 和 [@{} mutableCopy]]]></title>
      <url>%2F2017%2F01%2Fmutablecopy-array-dict-bad%2F</url>
      <content type="text"><![CDATA[糟糕的写法翻阅项目中的老代码，发现一百来处如下的写法：12NSMutableArray* array = [@[] mutableCopy];NSMutableDictionary *dict = [@&#123;&#125; mutableCopy]; 这种写法会多构造一个临时的对象，虽然随后就会回收销毁掉，毕竟多了内存申请释放的开销；从语法角度，这个写法也并不能节省多少时间，表意也不简明。 总结应该使用标准的创建对象的方式:12NSMutableArray* array = [NSMutableArray array];NSMutableDictionary* dict = [NSMutableDictionary dictionary];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS8上CGPathAddLineToPoint引起的crash]]></title>
      <url>%2F2017%2F01%2Fcrash-ios8-cgpathaddlinetopoint%2F</url>
      <content type="text"><![CDATA[Crash日志 如果传入的CGPoint的值是NaN, 就可能触发这个Crash:1234CGPoint pt = &#123; [[NSDecimalNumber notANumber] doubleValue], [[NSDecimalNumber notANumber] doubleValue]&#125;;CGPathAddLineToPoint(pt); // iOS8 crash here! 通过上述代码，模拟该crash，同时会在控制台看到如下输出：1Assertion failed: (CGFloatIsValid(x) &amp;&amp; CGFloatIsValid(y)), function void CGPathAddLineToPoint(CGMutablePathRef, const CGAffineTransform *, CGFloat, CGFloat), file Paths/CGPath.cc, line 265. 判断有效性在math.h中存在如下宏定义:1234#define isnan(x) \ ( sizeof(x) == sizeof(float) ? __inline_isnanf((float)(x)) \ : sizeof(x) == sizeof(double) ? __inline_isnand((double)(x)) \ : __inline_isnanl((long double)(x))) 结语以上crash只存在于iOS8的各版本系统，猜测CGPathAddLineToPoint这个函数的内部实现中，增加了断言，正式发布时未被去掉。解决方案可以先判断CGPoint的有效性，然后再进行绘制。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView中多出来的header]]></title>
      <url>%2F2016%2F11%2Fissue-tableviewheader%2F</url>
      <content type="text"><![CDATA[UITableView异常的35高度header如果UITableView的样式是UITableViewStyleGrouped，那么在设置它的tableViewHeader属性时，可能会遇到一些问题。 1.如果不设置tableViewHeader，那么顶部不会出现header的区域，但一旦调用1self.tableView.tableViewHeader = nil; 头部就会出现高度为35的一个区域。 2.即便不设置为nil,创建一个View, 但没有高度，仍旧会出现这样的情况:1self.tableView.tableViewHeader = [[UIView alloc] initWithFrame:CGRectNull]; 解决方案解决这个问题，只能设置一个高度极小的view:1self.tableView.tableViewHeader = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在XCode 8 中支持iOS 7 设备调试]]></title>
      <url>%2F2016%2F10%2Fxcode8-support-ios7-devices%2F</url>
      <content type="text"><![CDATA[下载下方附件中的文件，解压并拷贝到如下路径，然后重启XCode 8即可。 /Applications/Xcode-GM.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/ 附件： 设备支持文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个成功的Git分支管理模型]]></title>
      <url>%2F2016%2F09%2Fa-successful-git-branching-model%2F</url>
      <content type="text"><![CDATA[Git分支管理是一门艺术最近在看一个开源项目Beego Framework的介绍，其中在其项目的分支说明中看到了这张图片，然后又进一步查到了原文出处。拜读原文之后，觉得这个Git的分支管理模型非常棒。 之前自己对git分支的管理上，为了方便任务分配是按开发人员来划分的。但对版本迭代来驱动产品的开发，显然这个模型更合适。而且，原作者用图例和文字详细的描述了这个模型，简直棒极了。 整个模型可以用一个图来表示：更多的内容，请阅读下方的参考文档。 参考文档 A successful Git branching model (by Vincent Driessen) GIT分支管理是一门艺术]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[再见，iOS 7]]></title>
      <url>%2F2016%2F08%2Fgoodbye-ios7%2F</url>
      <content type="text"><![CDATA[初遇2013年秋， Apple推出了iOS 7，算得上iOS历史上一次最大的变革。完全重新设计的UI，引领了后面的扁平化的潮流。 还记得iOS 7正式推出后，如何让App适配iOS7和之前的iOS两种截然不同的外观，煞费苦心。 再见XCode 8 Beta版本中，已经无法选择7.x为最低的支持版本了，而且尝试使用iOS7.x的设备调试时，也会弹出提示，不再支持iOS 8之前的设备。随着9月份iOS 10正式版本的推出，XCode 8也会正式推出，作为一个开发者可以预见到，主流的App都会逐步升级，抛弃iOS7。 再见，iOS 7。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速开启HTTP服务器]]></title>
      <url>%2F2016%2F08%2Ffast-local-web-host%2F</url>
      <content type="text"><![CDATA[Python快速快速搭建Web服务器确保已经有Python环境，使用命令行快速搭建Web服务器1python -m SimpleHTTPServer 80 当前所在的文件夹设置为默认的Web目录，后面的80端口是可选的，不填会采用缺省端口8000。浏览器敲入地址1http://localhost:80 如果当前文件夹有index.html文件，会默认显示该文件。 参考文档 SimpleHTTPServer — Simple HTTP request handler]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用iOS 10 SDK编译的警告]]></title>
      <url>%2F2016%2F08%2Fios10-warnings%2F</url>
      <content type="text"><![CDATA[升级XCode 8 betaXCode 8 Beta使用了iOS 10 SDK为默认的SDK；目前的工程，使用XCode 8 Beta编译时，提示了一些警告信息。 Method possibly missing a [super awakeFromNib] call使用XCode 7时并没有报出这样的警告，其实故名思议，需要在awakeFromNib方法里面调用其父类的方法。1234- (void)awakeFromNib &#123; [super awakeFromNib]; // Initialization code&#125; 关于这点，Apple的官方文档中也有说明: You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require. Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations. You may call the super implementation at any point during your own awakeFromNib method. CAAnimationDelegateCAAnimationDelegate在iOS 9 SDK及之前的SDK中，作为NSObject的Category：1234@interface NSObject (CAAnimationDelegate)- (void)animationDidStart:(CAAnimation *)anim;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;@end CAAnimationDelegate在iOS 10 SDK中作为Protocol需要被类实现：12345@protocol CAAnimationDelegate &lt;NSObject&gt;@optional- (void)animationDidStart:(CAAnimation *)anim;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;@end 如果要兼容XCode 7 和XCode 8，则可以通过判断SDK版本来实现：12345678#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000@interface SomeClass &lt;AnyProtocal, CAAnimationDelegate&gt;#else@interface SomeClass &lt;AnyProtocal&gt;#endif- (void)anyMethod;@end CALayerDelegate与前面提到的CAAnimationDelegate类似，CALayerDelegate在iOS 9 SDK及之前的SDK中，作为NSObject的Category：123456@interface NSObject (CALayerDelegate)- (void)displayLayer:(CALayer *)layer;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;- (void)layoutSublayersOfLayer:(CALayer *)layer;- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event;@end iOS 10 SDK中作为Protocol需要被类实现：12345678@protocol CALayerDelegate &lt;NSObject&gt;@optional- (void)displayLayer:(CALayer *)layer;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;- (void)layerWillDraw:(CALayer *)layer CA_AVAILABLE_STARTING (10.12, 10.0, 10.0, 3.0);- (void)layoutSublayersOfLayer:(CALayer *)layer;- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event;@end 如果要兼容XCode 7 和XCode 8，则可以通过判断SDK版本来实现，同CAAnimationDelegate。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清理iOS工程中的Warnings]]></title>
      <url>%2F2016%2F08%2Fclear-ios-warnings%2F</url>
      <content type="text"><![CDATA[直接屏蔽对应的警告可以添加编译器选项，全局屏蔽掉某个警告，例如：1-Wno-deprecated 也可以屏蔽掉某段代码中的指定警告，例如：1234#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks"// Existing code here!#pragma clang diagnostic pop Pods中的WarningsCocoaPods禁止显示警告，Pod文件的头部中添加 inhibit_all_warnings!，这个实际上会在导入的第三方代码中，自动添加编译选项-w -Xanalyzer -analyzer-disable-all-checks。 Unused variable ‘xxx’没有使用到的变量，可能由于长期维护删减代码，部门声明的变量已经没有用到，可以采用的方式有： 注释掉该代码或直接删除； 添加_unused关键字； Method ‘xxx’ in protocol ‘yyy’ not implemented声明在某个class中实现了yyy协议，但是并没有实现xxx方法。 首先应该排查逻辑错误，如果没有实现一个required的方法很可能会引起逻辑错误，特别时当该方法有返回值的时候； 其次如果protocol也是自己的代码，则审查一下是否该method可以标记为optional； 然后实现该方法，如果实在没有用到则添加一个空的实现。 Deprecations代码中使用到了被SDK标记为deprecated的类或方法，往往这些类或者方法的定义处，都会提示替代的方式，按照所提示的替代换用新的类或者方法即可。 Switch condition has boolean value对一个Boolean类型的值用switch语句。这个改成if-else语句即可，同时也需要去审查一下该部分的逻辑，是否有其他问题。 Implicit conversion loses integer precision: ‘long’ to ‘int’常见于包含的C/C++代码，往往是用到的第三方代码。可以采用关闭该警告的方式去除。1Apple LLVM 7.1 - Warnings Policies - Implicit Conversion to 32 Bit Type - No PerformSelector may cause a leak because its selector is unknown代码中使用performSelector时会引起该警告，首选需要确认的是代码中已经明确通过respondsToSelector判断是否存在使用到的方法，然后才调用的performSelector。可以通过局部屏蔽改警告的方式处理。1234#pragma clang diagnostic push#pragma clang diagnostic ignored "-Warc-performSelector-leaks"// Existing code here!#pragma clang diagnostic pop Values of type ‘NSInteger’ should not be used as format arguments; add an explicit cast to ‘long’ instead在模拟器和真机上，NSInteger是不同的类型定义：1234567#if __LP64__ || (TARGET_OS_EMBEDDED &amp;&amp; !TARGET_OS_IPHONE) || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64 typedef long NSInteger; typedef unsigned long NSUInteger;#else typedef int NSInteger; typedef unsigned int NSUInteger;#endif 在格式化字符串时，使用’%ld’会在真机中报该警告。解决办法： use %zd for signed, %tu for unsigned, and %tx for hex. Incompatible pointer to integer conversion initializing ‘BOOL’ (aka ‘signed char’) with an expression of type ‘NSNumber * ‘把一个NSNumber对象赋值给了BOOL变量，这个往往会导致严重的逻辑问题，因为只要NSNumber对象不为nil，BOOL类型的变量都将是YES。需要修改代码：123NSNumber* value = @(0);// BOOL ok = value;BOOL ok = [value boolValue];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 10 Developer Beta 1]]></title>
      <url>%2F2016%2F06%2Fios10-beta-1%2F</url>
      <content type="text"><![CDATA[在WWDC 2016上，Apple公司发布了iOS 10，带来了一些新的特性，并同步升级了开发工具（XCode 8， 含iOS 10 SDK）和 Swift 3。目前，作为开发者可以下载到XCode8-beta版本提前尝试开发和适配iOS 10的新特性。 iOS 10 SDK 包含了新的API和服务，可以开发新的App类型和新的功能。App能够去扩展Message、Siri、Phone、Maps，来提供更加吸引人的功能。 比如iOS 10可以通过Extension去识别来电，这样可以实现识别和屏蔽骚扰电话了，可以想象，iOS10正式推出时，各大助手类App、通讯录类App都将第一时间跟进该功能。 安装 iOS10 Developer Beta 1 版本直接下载对应版本的安装包，然后通过iTunes安装会报错，ERROR（14）。在手机上安装配置文件(此处下载)，然后通过OTA的方式升级。 Siri KitiOS 10 正式对App开放了Siri的服务，App可以通过创建新的Intents Extension Intents UI Extension，为Siri提供几种特定范围的服务。Siri识别用户发出的指令，交给注册的Extension去执行，最后生成返回页面。iOS 10支持的服务范围如下： Audio or video calling Messaging Sending or receiving payments Searching photos Booking a ride Managing workouts Proactive Suggestions相比iOS 9，对这部分的功能进行了提升。在App内记录用户的一些行为特征，那么系统在一些场景下会向用户推荐App里面的内容。比如输入文字时QuickType建议，Maps内的一些推荐，Siri交互时的一些推荐，等等。 Integrating with the Messages AppiOS 10对iMessages进行很大的扩展，允许用户通过Sticker Pack Extension扩展表情包，还能通过Messages Extension自定义的页面来提供文字、图片、多媒体文件甚至交互式的消息。 User NotificationsiOS 10封装了独立的UserNotifications.framework和UserNotificationsUI.framework来处理本地和远程的通知。提供了Notification Content Extension Notification Service Extension自定义通知的显示UI。 Speech Recognition通过Speech.framework来识别语音并转换为文字。 Wide ColorCore Graphics, Core Image, Metal, and AVFoundation等提供sRGB支持，UIColor会默认使用sRGB色彩空间。 Adapting to the True Tone Display可以配置App来适应True Tone Display。 App Search Enhancements对iOS 9 引入的 CoreSpotlight framework增强的功能。 Widget EnhancementsiOS 10支持了锁屏页面的Widget显示，这里增强了显示效果以适应不同的背景。 Apple Pay EnhancementsiOS 10增强了JS版本的Apple Pay支持，Mac的网页上发起支付也可以在iPhone或者AppleWatch上响应；并提供了一个新的测试环境来绑定银行卡和完成支付。 Security and Privacy Enhancements增加了很多安全和隐私方面的限制，对App而言，需要在plist显式的注册App所用到的权限，包括摄像头联系人访问、日历访问等等，如果没有在plist注册相关的权限，App在运行中去尝试申请用户授权时会直接出现异常。具体可以查看参考资料#4。 备注：这个应该是使用iOS 10 SDK必须要做的适配。 CallKitApp可以集成VOIP的服务到iPhone UI。并且可以通过Call Directory Extension来实现来电识别和屏蔽的功能。 News Publisher EnhancementsNews Publisher的增强。 Video Subscriber Account提供一个视频订阅的账号框架，用于自动认证。 App ExtensionsiOS 10新增多个Extension类型，在前面具体涉及到的地方都有提到，在XCode 8创建新的Target时可以选择。 Call Directory Extension Intents Extension Intents UI Extension Messages Extension Notification Content Extension Notification Service Extension Sticker Pack Extension Additional Framework Changes &amp; Deprecated APIs涉及到很多API的变更，新的类、枚举、方法，也有标记失效的API。比较多，详情请查看参考资料#1。 总结重要的兼容性适配工作 iOS 10 加强了安全和隐私的策略，App需要在plist中显式的注册所需要用到的访问权限（摄像头的访问照片的访问等），否则运行在iOS10上面是会出现异常而导致功能无法正常使用； 如果有用到Deprecated APIs，需要做一些修改； 如果有使用Swift代码，随XCode 8一起发布的Swift 3并不能兼容Swift2.x代码，XCode本身提供了自动的代码转换功能，可能也会需要手动调整。 需要重点关注的新特性 iOS 10 支持定制化Notification的显示UI，可以极大的丰富本地通知和推送通知的展示方式； iOS 10 提供了App对Siri指令的响应扩展，可以通过Siri为用户提供App内部的内容，并可以定制展示的UI； iOS 10 提供了App对iMessage的扩展，可以让我们实现在iMessage聊天，发送定制化的消息；提供无缝的体验，不用切换App； Apple Pay的增强，可以加强支付体验； Proactive Suggestions的增强，App内部记录用户的一些行为提供给iOS系统，提高用户使用手机的其他功能时的体验，让用户觉得iOS更加智能的同时，也提升对App的好感。 参考资料 What’s New in iOS 10 WWDC 2016 Videos iOS 10 Preview Information Property List Key Reference - Cocoa Keys Information Property List Key Reference - iOS Keys Top 35 iOS 10 Features]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown标记语言]]></title>
      <url>%2F2016%2F04%2Fmarkdown-intro%2F</url>
      <content type="text"><![CDATA[Markdown标记语言Markdown 语法说明 (简体中文版) Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 创始人 John Gruber 的 Markdown 语法说明 Markdown is intended to be as easy-to-read and easy-to-write as is feasible. Readability, however, is emphasized above all else. A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters — including Setext, atx, Textile, reStructuredText, Grutatext, and EtText — the single biggest source of inspiration for Markdown’s syntax is the format of plain text email.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[语义化版本]]></title>
      <url>%2F2016%2F04%2Fsem-ver-intro%2F</url>
      <content type="text"><![CDATA[语义化版本语义化版本(SemVer) 中文说明 版本格式：主版本号.次版本号.修订号，版本号递增规则如下：主版本号：当你做了不兼容的 API 修改，次版本号：当你做了向下兼容的功能性新增，修订号：当你做了向下兼容的问题修正。先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac系统命令行工具的一些用法]]></title>
      <url>%2F2016%2F04%2Fmacosx-cli-tips%2F</url>
      <content type="text"><![CDATA[sips批量处理图片查看图片的属性1$ sips -g all sample.jpg 输出： Users/xinus/tmp/sample.jpg pixelWidth: 3648 pixelHeight: 2736 typeIdentifier: public.jpeg format: jpeg formatOptions: default dpiWidth: 72.000 dpiHeight: 72.000 samplesPerPixel: 3 bitsPerSample: 8 hasAlpha: no space: RGB profile: sRGB IEC61966-2.1 creation: 2010:03:18 11:08:11 make: OLYMPUS IMAGING CORP. model: FE5000,X905 software: Version 1.0 description: OLYMPUS DIGITAL CAMERA 修改图片1234567891011121314# 旋转图片 90度$ sips -r 90 sample.jpg --out sample-1.jpg# 旋转图片 -90度$ sips -r -90 sample.jpg --out sample-2.jpg# 指定长宽的最大值，等比例缩放，这个例子中，执行后sample-3.jpg宽度600px，高度450px$ sips -Z 600 sample.jpg --out sample-3.jpg# 指定长宽值缩放，这个例子中，执行后sample-4.jpg宽度300px，高度400px$ sips -z 400 300 sample.jpg --out sample-4.jpg# 水平翻转$ sips -f horizontal sample.jpg --out sample-5.jpg# 垂直翻转$ sips -f vertical sample.jpg --out sample-6.jpg# 指定长宽值裁剪, 会以图片中点开始计算，不足的会补上黑色$ sips -c 400 300 sample.jpg --out sample-7.jpg 更多方式可以查看sips的帮助说明1$ sips -h 查询某个命令的路径12$ command -v gcc&gt; /usr/bin/gcc Homebrew的使用安装Homebrew1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 通过Homebrew安装包1$ brew install wget cmake]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac系统连接Windows打印机]]></title>
      <url>%2F2016%2F04%2Fmacosx-printer%2F</url>
      <content type="text"><![CDATA[公司的网络是组了域的，Windows PC访问打印机很容易，直接再地址栏键入打印机地址，就可以访问到，比如\\GROUP_PRINTER_SERVER\CTU_F88W167_HP_m706n_PRT1001。 我的Mac并没有加入域，所以配置时，需要用IP地址来代替主机名称。 打开System Preference...，找到Printers &amp; Scanners并打开。 如下图，点击+添加新的打印机。 如下图，在Add页面中，如果工具栏中没有Advanced，可以再工具栏区域点击右键，在弹出菜单中选择Customize Toolbar...，出现入下图的界面后，把Advanced拖拽到工具栏，然后确认。 如下图，在Add页面中，切换到Advanced，填入打印机的相关信息，因为没有加入域，需要用IP地址替代主机名，最后点Add添加，如果一切正常，会提示是否双面打印，然后确认。 完成上述步骤后，可以打开一份Word文档来测试打印，打印时会询问用户名和密码，正确填写即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中AutoLayout引起的一个动画问题]]></title>
      <url>%2F2016%2F04%2Fautolayout-animation-issue%2F</url>
      <content type="text"><![CDATA[先说说大概的情况我做了一个ConnectingView，用来显示一个连接中的动画。动画中有三部分，手机图标、服务器图标、循环移动的虚线。大致的示意如下： [App] = - - - - [Server] [App] - = - - - [Server] [App] - - = - - [Server] [App] - - - = - [Server] [App] - - - - = [Server] 整个ConnectingView用AutoLayout布局，然后动画部分通过改变进度条‘=’与左边[App]的间距约束来实现。然后再ViewController的viewDidLoad方法中，实例化ConnectingView，并通过代码设置AutoLayout放置在view中，然后startAnimation。 动画问题及原因接着发现一个动画问题，再部分手机上，进入这个ViewController并开始动画时，进度条‘=’的初始位置可能会超过[App], 但第2次循环时，不会超过。 经过调查，这个问题的原因在于动画开始的时候，与AutoLayout重新布局存在时间上的冲突。 ConnectingView通过XIB设计，ViewController是在StoryBoard中设计。ViewController的viewDidLoad是程序载入StoryBoard中的设计完成，而初始的尺寸也就是Storyboard的尺寸；ConnectingView通过XIB实例化，初始的尺寸也是XIB的尺寸，虽然我们设置了AutoLayout，但整体的布局还没有适配屏幕；这个时候我们开始动画，也就是计算动画的初始位置都还是原始的尺寸。viewDidLoad完成后，再viewDidAppear之前的时间节点中，ViewController根据需要整体重新布局，而我们的动画已经照旧的位置已经开始，这时候的冲突就造成了前面提到的问题。 最后的解决开始，我尝试过让动画开始的时间延后一定时间开始，或者干脆到ViewDidAppear中再开始动画，而不是viewDidLoad。这样虽然不会出现上面提到的问题，但明显能感觉到延迟，约0.5s左右，肉眼可以感知。 后来，我尝试把UIView这一层的动画，改为CALayer这一层的动画，问题就完美解决了。这也许是因为我不通过设置View本身属于AutoLayout中的约束（Constraint）来进行动画，而通过CALayer这一层避开了AutoLayout适应布局时的冲突。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WeiboSDK授权登录的问题]]></title>
      <url>%2F2016%2F04%2Fweibo-ios-sdk-issue%2F</url>
      <content type="text"><![CDATA[WeiboSDK授权登录的问题最近的一个项目里面，集成了WeiboSDK，主要是要用到OAuth授权登录。这个问题发现得比较早，但是一直没有出来。目前手上其他优先级高的任务都完成了，这个Bug自然需要解掉。 先说说Bug的现象。App集成了Weibo的SDK，版本3.1.1，按照文档所列的要求，完成的所有关联的配置，包括对iOS9的支持。 iPhone上安装最新的Weibo客户端，并登录一个账号； 在我们的App中（简称App）进入登录页面，点Weibo的图标，Weibo客户端会被调用至前台，出现授权页面； 若该账号第一次授权，则一切正常；会正确的出现App的图标和相应的描述；点击确认按钮，完成授权并切回App； 若账号以前授权过，授权页面会正常显示，但不需要用户点击确认按钮，自动授权完成，并切回App。 这个问题比较严重，因为： 不再给用户决定的权利，跳过确认直接授权登录； 如果Weibo客户端上有多个账户，无法让用户切换账号。 暂时无解基本认定了是Weibo自己某种缓存机制作怪，翻了几遍文档和SDK的API，没有找到任何可以去取消这种直接授权的参数。尝试给SDK Team写邮件，被拒收了。对外公布的邮箱，竟然不接收外部邮件。好在加入了他们的QQ讨论群，得到的答复也基本如此： 这个是微博的机制，就是这样的，微博内有授权缓存，判断一段时间内授权过得应用，默认不需要手动操作。说服QA的话，用其他线上app演示一下不就行了？文档不好找，这机制蛮久了。 虽然不太喜欢“其他App都是如此，所以如此也没有什么问题”的意思。但目前看来无解，这个问题暂时标记为As Designed，结束。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[遭遇苹果的显卡门]]></title>
      <url>%2F2016%2F04%2Fmacbookpro-videoissues%2F</url>
      <content type="text"><![CDATA[工作电脑突然坏了前段时间，工作用的MacBookPro坏了，就在桌上放了一夜，第二天就无法进入系统。具体的现象如下： 开机后，出现苹果的Logo，下方的进度条在三分之一处停止不动，然后会有几种情况， - 有一定的几率直接重启； - 有一定的几率直接白屏，而且风扇的声音很大； - 有极小极小的几率能顺利的启动。 天才吧检测出显卡门驱车一小时来到就近的Apple Store，没有提前预约，又排队两个小时。经过工作人员的检测，确定电脑的故障是显卡门缺陷导致的。关于显卡门可以看这里：适用于视频问题的 MacBook Pro 维修扩展计划。 工作人员说可以换主板，但是目前店里面没有货，需要从其他门店调，可能要一周。原因找到了，但维修的建议我并未采纳，因为： - 出于数据安全考虑，不能把电脑留在店里面一周； - 我需要把电脑寄回公司，由IT解决； - 公司重新寄了一台电脑给我，已经在路上了。 然后开始了折腾之旅。 折腾之旅公司寄的电脑很快就到了，但是一些资料，需要转移到新的电脑上。这时，我开始了折腾，虽说结果看来，有些似乎没有意义，但生命在于折腾，不是么？ 显卡既然不能用，那么我进入纯命令行模式，那么系统就能跑起来，然后挂载个U盘，或者开启个ftp服务，那么资料就能拷贝出来了？！ 单用户模式开机按住⌘+s，系统会进入单用户模式，其实就是一个纯命令行模式。再这个模式下，能够访问到系统盘下面的所有数据，但不巧的是，我硬盘当时单独分了一个区放了部分数据，而这个分区无论如何都挂载不上。此外，单用户模式下面，是没有网络支持的。所以，这种方式只能作罢。 目标磁盘模式开机按住⌘+t，系统进入目标磁盘模式。也就是两台Mac电脑连在一起，另外一台电脑可以把这台电脑当做一个大大的移动硬盘，访问上面的数据。不得不说，这个功能非常好。但是限制也是有的，就是连接线。OS X系统支持两种连接方式：一个是苹果自己的Thurdblot雷电连接线，另外一个是Firewire火线连接。这两种线我手上都没有。所以，这种方式只能作罢。 Linux引导启动那么，换个系统如何？我突然想起柜子里面有几年前刻录的Ubuntu安装光盘，可以直接Live CD的方式运行Ubuntu。于是我找到了Ubuntu光盘，另外还有几张没有刻录的空白DVD光盘。 光盘启动Ubuntu把Ubuntu的光盘放入光驱，然后⌘+o光盘启动，看到Ubuntu选择启动的界面，瞬间觉得希望在前面。但是很快，希望就破灭了。启动项里面都是带界面的，所以启动到一半就提示错误，应该还是显卡的问题。或许，我找个纯命令行界面的Linux发行版，能解决这个问题。 Tips: MacBook 开机按住触摸板，可以在加载系统前，弹出光驱中的光盘。 USB启动TinyCoreTinyCore是一个非常小巧的发行版。Core版本只有4M左右，带GUI界面的10M左右，功能全一点的100M。正好车上有个2G的USB用来播放歌曲的，直接拿来做启动盘。从网上下载好了TinyCore的iso虚拟盘，并把U盘制作成了启动盘。1$ dd of=/dev/disk4 if=tinycore.iso 然后，启动盘制作好了后，坏掉的Macbook竟然无法从U盘启动。开机⌘+o并不会出现U盘，也许是USB接口供电不够，无论如何这条路不行。所以只好还原了U盘。1$ dd of=/dev/disk4 if=/dev/zero 既然还有空白的光盘，不如刻录一张，继续从光盘启动？ 光盘启动TinyCorePlus这次，我下载的TinyCorePlus版本，并通过Virtual Box创建了个虚拟机，测试里面同样包含纯命令行的启动方式。接下来要做的就是刻录光盘了。网上的教程上都说，通过系统自带的磁盘工具可以直接刻录光盘，但事实上，我看到的不太一样，也许是因为我的系统是目前最新的 OS X 10.11 EI Capitan。花了一点时间，找到个免费的好工具Burn, 最终完成了光盘启动盘的制作。 放入光盘，顺序启动，甚至带GUI的选项也能启动，可能是没用到显卡吧。然后才意识到一个很严重的问题，根本无法访问OS X系统下面的数据。因为OS X系统分区和另外一个数据分区，都默认使用了HFS+文件系统，而TinyCore是没有提供支持的。所以，挂载不上这两个分区，也就不能访问里面的数据。好吧，折腾了这么久，原来都是瞎折腾-_-!。 最简单粗暴的解决办法万万没想到，我最后还是把数据拷贝出来了。我手上有两台电脑，一台无法进入系统，一台正常，而他们都是MacbookPro。于是，我干嘛不直接换硬盘呢？是的，我真这么干了。 MacbookPro后盖上一共10颗螺丝，其中3颗比较长，拆下的时候我习惯按顺序摆放。后盖卸下来后，硬盘位于左下角，硬盘上方有一个挡条，上面两颗螺丝卸下来后，硬盘就能直接取下。然后把硬盘换入正常的电脑，就可以启动，并进入系统备份资料，删除资料，后面删除整个用户清除个人数据。最后把硬盘还原回去，接着就可以把电脑寄回去了。 后记换个情景，也许开始在天才吧就能处理好，也就没有后续这么多事情。后面的过程真的很折腾，似乎也没什么用，但是这种折腾让我找到久违的痛快。 Mac系统下显示dd的进度通过brew安装pv，然后切换到root1$ pv -cN source &lt; /dev/zero | dd of=/dev/disk3 bs=4m]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[不忘初心 淡然前行]]></title>
      <url>%2F2016%2F04%2Fhello-world%2F</url>
      <content type="text"><![CDATA[以前的事2009年春，我饶有兴致的开始更新自己的技术博客，每天看着几十的访问量也是很开心。虽然在今天看来多数都是转载的文章，原创的部分也缺乏深度，但那时的我却是认认真真的在做这件事。那时候关注的技术，主要是Linux和Qt，也很有兴趣的研究着SDL，一心想做个跨平台的小游戏。 一年多后，工作的变迁，离开了原来工作的城市，进入新的环境，原本坚持下来的东西，慢慢的就淡了。也许少了之前的兴奋劲，也许觉得自己码出来文字缺少营养，也许就简单的时因为懒了。总之，原本的博客被自己遗忘了，也没再拾起来。 新的开始再翻起之前的博客，突然觉得这些年有许多遗憾，走得太远却忘记了自己为何出发。那些简简单单的文字，毕竟记录了当时的自己。岁月流逝，环境变了，心态变了，而那时的我依然存在于那些简简单单的文字中。中间的这些年，虽感觉自己成长了，有所收获，但有时候又莫名感到悲伤。或许，是时候重新出发了，而这里就是新的开始。1Hello World!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS抗锯齿的方式]]></title>
      <url>%2F2013%2F10%2Fios-edge-antialisasing%2F</url>
      <content type="text"><![CDATA[iOS开发中，有时候展示图片等内容的时候，会出现锯齿。比如笔者最近使用 iCarousel 控件的Cover flow效果来展示几幅图片时，两侧的图片出现了较为严重的锯齿，着实不好看。这里列出两个方式： 在info.plist中打开抗锯齿，但是会对影响整个应用的渲染速度； 12Renders with edge antialisasing = YES （UIViewEdgeAntialiasing）Renders with group opacity = YES （UIViewGroupOpacity） View.layer.shouldRasterize = YES；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS系统控件显示中文]]></title>
      <url>%2F2013%2F10%2Fios-localization-cn%2F</url>
      <content type="text"><![CDATA[App中使用系统控件，一般默认会显示英文，即便系统的语言环境设置的是简体中文。这需要在App的工程中加入中文支持，这样在中文的系统环境下，调用的系统控件，比如“返回”而不是“Back”。 步骤如下：为工程添加中文的本地化支持。 在XCode中打开工程; 左侧的工程栏中，选中工程，出现工程信息的页面。在Info标签页中，在”Localizations”部分，点击“+”添加“Chinese（zh-Hans）”; 新建文件“Localizable.strings”，并添加中文的本地化支持。 选中“Localizable.strings”文件，并打开最后侧的“File Inspector”； 在”Localization”部分中，点击“+”添加“Chinese（zh-Hans）”; 重新编译App，设备切换到简体中文语言环境时，查看运行结果 :)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIButton设置了UIControlStateSelected和UIControlStateHighlighted状态的图片点击会闪烁的解决方案]]></title>
      <url>%2F2013%2F06%2Fuibutton-state-issue%2F</url>
      <content type="text"><![CDATA[通过代码增加如下设置:12[btn setBackgroundImage:img1 forState:UIControlStateSelected|UIControlStateHighlighted];[btn setImage:img2 forState:UIControlStateSelected|UIControlStateHighlighted]; 注: 在界面设计器中无法设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发陷阱之NSString - compare]]></title>
      <url>%2F2013%2F01%2Fnsstring-compare-trap%2F</url>
      <content type="text"><![CDATA[NSString有多个compare相关方法：1234- (NSComparisonResult)compare:(NSString *)string;- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange;- (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask range:(NSRange)compareRange locale:(id)locale; NSComparisonResult 是定义的一个枚举，定义如下：1typedef NS_ENUM(NSInteger, NSComparisonResult) &#123;NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending&#125;; 其中，NSOrderedSame 表示比较的两个字符串完全一致, 同时，在这个枚举中，它的值是 0.字符串比较在程序中很常见，比如：123456if ([str1 compare:@"some text"] == NSOrderedSame) &#123; // Do something&#125;else &#123; // Do something else&#125; 但，如果如上中的str1为nil，根据Objective-C的消息调用规则（方法调用），对nil发送的任何消息，得到的返回都是nil。这样的情况下，运行时是不会像C/C++那样，出现空指针的非法访问而使得程序强行终止。也就是说，在Objective-C下面，即便str1为nil，也不会造成程序崩溃，而是会继续运行。 那么当str1为空的时候，[str1 compare:@”some text”] 消息的返回就会为nil。nil表示一个空的Objective-C对象，实际就是表示一个空指针，而它代表的值就是0，与NSOrderedSame的值相等. 如此，回到最前面的if语句，如果str1为nil，那么整个语句的值为真。这会给程序造成非常严重的问题，小则逻辑错误，UI显示错误等，大则会造成数据泄漏等等。。。所以，一旦出现这种情况，还是很严重的。 笔者个人建议，以上代码至少应该写为：123456if (str1!=nil &amp;&amp; [str1 compare:@"some text"] == NSOrderedSame) &#123; // Do something&#125;else &#123; // Do something else&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS全局处理键盘事件]]></title>
      <url>%2F2013%2F01%2Fios-keyboard-listening%2F</url>
      <content type="text"><![CDATA[注册监听键盘事件的通知12345678910111213141516171819[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardShow:) name:UIKeyboardDidShowNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardHide:) name:UIKeyboardDidHideNotification object:nil]; 在键盘将要出现和隐藏的回调中，加入动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)keyboardWillShow:(NSNotification *)notif &#123; if (self.hidden == YES) &#123; return; &#125; CGRect rect = [[notif.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue]; CGFloat y = rect.origin.y; [UIView beginAnimations:nil context:nil]; [UIView setAnimationDuration:0.25]; NSArray *subviews = [self subviews]; for (UIView *sub in subviews) &#123; CGFloat maxY = CGRectGetMaxY(sub.frame); if (maxY &gt; y - 2) &#123; sub.center = CGPointMake(CGRectGetWidth(self.frame)/2.0, sub.center.y - maxY + y - 2); &#125; &#125; [UIView commitAnimations];&#125;- (void)keyboardShow:(NSNotification *)notif &#123; if (self.hidden == YES) &#123; return; &#125;&#125;- (void)keyboardWillHide:(NSNotification *)notif &#123; if (self.hidden == YES) &#123; return; &#125; [UIView beginAnimations:nil context:nil]; [UIView setAnimationDuration:0.25]; NSArray *subviews = [self subviews]; for (UIView *sub in subviews) &#123; if (sub.center.y &lt; CGRectGetHeight(self.frame)/2.0) &#123; sub.center = CGPointMake(CGRectGetWidth(self.frame)/2.0, CGRectGetHeight(self.frame)/2.0); &#125; &#125; [UIView commitAnimations];&#125;- (void)keyboardHide:(NSNotification *)notif &#123; if (self.hidden == YES) &#123; return; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS/Objective-C 开发常用代码(1)]]></title>
      <url>%2F2012%2F12%2Fcode-fragments-oc-1%2F</url>
      <content type="text"><![CDATA[判断iOS设备是否是iPad1#define IS_IPAD ([[UIDevice currentDevice] respondsToSelector:@selector(userInterfaceIdiom)] &amp;&amp; [[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad) iOS中URL编码12NSString* escapedURLString = [unescapedStringstringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding] 或123NSString * encodedString = (NSString *)CFURLCreateStringByAddingPercentEscapes(NULL, (CFStringRef)yourtext, NULL,(CFStringRef)@”!*’();:@&amp;=+$,/?%#[]“, kCFStringEncodingUTF8); iOS中不定参数（可变参数）的方法常见于NSArray初始化方法中，比如：12345@interface NSArray (NSArrayCreation)+ (id)arrayWithObjects:(id)firstObj, ... NS_REQUIRES_NIL_TERMINATION;- (id)initWithObjects:(id)firstObj, ... NS_REQUIRES_NIL_TERMINATION;//...@end NS_REQUIRES_NIL_TERMINATION 是一个宏，用于编译时非nil结尾的检查。自定义不定参数的方法与C/C++一样，示例如下：12345678910111213141516- (id)initWithColumns: (NSString*)firstColumnName, ... &#123; if (self = [self init]) &#123; NSMutableArray* arrays = [NSMutableArray array]; va_list argList; if (firstColumnName) &#123; [arrays addObject:firstColumnName]; va_start(argList, firstColumnName); id arg; while ((arg = va_arg(argList, id))) &#123; [arrays addObject:arg]; &#125; &#125; self.columnNames = [NSArray arrayWithArray:arrays]; &#125; return self;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSDateFormatter格式详细列表一览]]></title>
      <url>%2F2012%2F10%2Fnsdateformatter-intro%2F</url>
      <content type="text"><![CDATA[前言iOS开发中NSDateFormatter是一个很常用的类，用于格式化NSDate对象，支持本地化的信息。与时间相关的功能还可能会用到NSDateComponents类和NSCalendar类等。本文主要列出NSDateFormatter常见用法。NSDate对象包含两个部分，日期（Date）和时间（Time）。格式化的时间字符串主要也是针对日期和时间的。[以下代码中开启了ARC，所以没有release。] 基础用法1234567NSDate* now = [NSDate date];NSDateFormatter* fmt = [[NSDateFormatter alloc] init];fmt.dateStyle = kCFDateFormatterShortStyle;fmt.timeStyle = kCFDateFormatterShortStyle;fmt.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"];NSString* dateString = [fmt stringFromDate:now];NSLog(@"%@", dateString); 打印输出：10/29/12, 2:27 PM这使用的系统提供的格式化字符串，通过 fmt.dateStyle 和 fmt.timeStyle 进行的设置。实例中使用的参数是 kCFDateFormatterShortStyle，此外还有： 1234567typedef CF_ENUM(CFIndex, CFDateFormatterStyle) &#123; // date and time format styles kCFDateFormatterNoStyle = 0, // 无输出 kCFDateFormatterShortStyle = 1, // 10/29/12, 2:27 PM kCFDateFormatterMediumStyle = 2, // Oct 29, 2012, 2:36:59 PM kCFDateFormatterLongStyle = 3, // October 29, 2012, 2:38:46 PM GMT+08:00 kCFDateFormatterFullStyle = 4 // Monday, October 29, 2012, 2:39:56 PM China Standard Time&#125;; 自定义区域语言如上实例中，我们使用的是区域语言是 en_US，指的是美国英语。如果我们换成简体中文，则代码是：1fmt.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"zh_CN"]; 则对应的输出为：1234567typedef CF_ENUM(CFIndex, CFDateFormatterStyle) &#123; // date and time format styles kCFDateFormatterNoStyle = 0, // 无输出 kCFDateFormatterShortStyle = 1, // 12-10-29 下午2:52 kCFDateFormatterMediumStyle = 2, // 2012-10-29 下午2:51:43 kCFDateFormatterLongStyle = 3, // 2012年10月29日 GMT+0800下午2时51分08秒 kCFDateFormatterFullStyle = 4 // 2012年10月29日星期一 中国标准时间下午2时46分49秒&#125;; 世界通用的区域语言代码，详见 International Components for Unicode (ICU), http://userguide.icu-project.org/formatparse/datetime 自定义日期时间格式NSDateFormatter提供了自定义日期时间的方法，主要是通过设置属性 dateFormat，常见的设置如下：123456NSDate* now = [NSDate date];NSDateFormatter* fmt = [[NSDateFormatter alloc] init];fmt.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"zh_CN"];fmt.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss";NSString* dateString = [fmt stringFromDate:now];NSLog(@"%@", dateString); 打印输出：2012-10-29T16:08:40 除了上面列出的，还可以指定很多格式，详见http://userguide.icu-project.org/formatparse/datetime。结合设置Locale，还可以打印出本地化的字符串信息。123456NSDate* now = [NSDate date];NSDateFormatter* fmt = [[NSDateFormatter alloc] init];fmt.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"zh_CN"];fmt.dateFormat = @"yyyy-MM-dd a HH:mm:ss EEEE";NSString* dateString = [fmt stringFromDate:now];NSLog(@"\n%@", dateString); 打印输出：2012-10-29 下午 16:25:27 星期一 自定义月份星期等字符NSDateFormatter中同样提供了相应的方式，去修改这些字符。一般情况下，使用相应区域语言下面的默认字符就OK了。但是你的确有这个需求，那么也是可以办到的。相应的方法非常多，如下： Managing AM and PM Symbols AMSymbol setAMSymbol: PMSymbol setPMSymbol: Managing Weekday Symbols weekdaySymbols setWeekdaySymbols: shortWeekdaySymbols setShortWeekdaySymbols: veryShortWeekdaySymbols setVeryShortWeekdaySymbols: standaloneWeekdaySymbols setStandaloneWeekdaySymbols: shortStandaloneWeekdaySymbols setShortStandaloneWeekdaySymbols: veryShortStandaloneWeekdaySymbols setVeryShortStandaloneWeekdaySymbols: Managing Month Symbols monthSymbols setMonthSymbols: shortMonthSymbols setShortMonthSymbols: veryShortMonthSymbols setVeryShortMonthSymbols: standaloneMonthSymbols setStandaloneMonthSymbols: shortStandaloneMonthSymbols setShortStandaloneMonthSymbols: veryShortStandaloneMonthSymbols setVeryShortStandaloneMonthSymbols: Managing Quarter Symbols quarterSymbols setQuarterSymbols: shortQuarterSymbols setShortQuarterSymbols: standaloneQuarterSymbols setStandaloneQuarterSymbols: shortStandaloneQuarterSymbols setShortStandaloneQuarterSymbols: Managing Era Symbols eraSymbols setEraSymbols: longEraSymbols setLongEraSymbols:]]></content>
    </entry>

    
  
  
</search>
